#!/bin/bash
set -e # Zakończ skrypt, jeśli którekolwiek polecenie zwróci błąd
set -o pipefail # Zakończ potok, jeśli którekolwiek polecenie zwróci błąd

# ==============================================================================
# Ultra Defender for Linux (UDfL) - Core Script
# Wersja 1.1.0 - Dodano Hartowanie Jądra (sysctl) i Integrację z Fail2Ban
# ==============================================================================

# --- === Konfiguracja Globalna === ---
PROJECT_NAME="Ultra Defender for Linux"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &> /dev/null && pwd)"
HOSTS_FILE="/etc/hosts"
EXCLUSIONS_FILE="${SCRIPT_DIR}/exclusions.txt"
LOG_FILE="/var/log/udfl.log"
BACKUP_DIR="/etc/udfl-backup"
STEVEN_BLACK_HOSTS_URL="https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts"
IPSET_NAME="udfl_blocklist"
IPTABLES_CHAIN="UDfL_BLOCK"

# --- === Logowanie === ---
log() {
    local message="$1"
    echo "$(date '+%Y-%m-%d %H:%M:%S') - ${message}" | tee -a "${LOG_FILE}"
}

# --- === Sprawdzenie Zależności i Uprawnień === ---
check_dependencies() {
    log "Sprawdzanie zależności..."
    local dependencies=("curl" "wget" "ipset" "iptables" "grep" "sed" "awk" "mktemp" "tee" "sysctl")
    local missing_deps=()
    for dep in "${dependencies[@]}"; do
        if ! command -v "${dep}" &> /dev/null; then
            missing_deps+=("${dep}")
        fi
    done

    if ! (command -v curl &> /dev/null || command -v wget &> /dev/null); then
         missing_deps+=("curl lub wget")
    fi

    if [ ${#missing_deps[@]} -gt 0 ]; then
        log "BŁĄD: Brakujące zależności: ${missing_deps[*]}. Proszę je zainstalować."
        exit 1
    fi

    if [ "$(id -u)" -ne 0 ]; then
        log "BŁĄD: Ten skrypt musi być uruchomiony z uprawnieniami roota (sudo)."
        exit 1
    fi
}

# --- === Wykrywanie Narzędzi Sieciowych === ---
detect_downloader() {
    if command -v curl &> /dev/null; then
        DOWNLOADER="curl"
    else
        DOWNLOADER="wget"
    fi
}

download_file() {
    local url="$1"
    local output_path="$2"
    log "Pobieranie pliku z ${url}..."
    if [ "$DOWNLOADER" == "curl" ]; then
        curl -s -L "${url}" -o "${output_path}"
    else
        wget -q -O "${output_path}" "${url}"
    fi
    if [ $? -ne 0 ]; then
        log "BŁĄD: Nie udało się pobrać pliku z ${url}."
        return 1
    fi
    return 0
}

# --- === Zarządzanie Plikiem Hosts === ---
manage_hosts() {
    log "Rozpoczynam zarządzanie plikiem ${HOSTS_FILE}..."
    mkdir -p "${BACKUP_DIR}" || { log "BŁĄD: Nie można utworzyć katalogu kopii zapasowych."; exit 1; }
    if [ ! -f "${BACKUP_DIR}/hosts.original" ]; then
        cp "${HOSTS_FILE}" "${BACKUP_DIR}/hosts.original" || { log "BŁĄD: Nie można utworzyć kopii zapasowej oryginalnego pliku hosts."; exit 1; }
    fi
    
    local temp_hosts=$(mktemp)
    if ! download_file "${STEVEN_BLACK_HOSTS_URL}" "${temp_hosts}"; then
        rm -f "${temp_hosts}"; return 1;
    fi
    
    local new_hosts_content=$(mktemp)
    grep -Ev '(^# Ultra Defender for Linux|^0\.0\.0\.0.*# UDfL_BLOCK)' "${BACKUP_DIR}/hosts.original" > "${new_hosts_content}"
    echo "" >> "${new_hosts_content}"
    
    echo "# ======================================================================" >> "${new_hosts_content}"
    echo "# Ultra Defender for Linux - Generated by UDfL on $(date)" >> "${new_hosts_content}"
    echo "# ======================================================================" >> "${new_hosts_content}"
    
    local temp_exclusions_filtered=$(mktemp)
    if [ -f "${EXCLUSIONS_FILE}" ]; then
        grep -v '^#' "${EXCLUSIONS_FILE}" | sed 's/\r$//' | grep -v '^[[:space:]]*$' > "${temp_exclusions_filtered}"
    fi

    awk '/^0\.0\.0\.0/ {print $2}' "${temp_hosts}" | grep -v -F -f "${temp_exclusions_filtered}" | sed 's/\r$//' | while read -r domain; do
        echo "0.0.0.0 ${domain} # UDfL_BLOCK" >> "${new_hosts_content}"
    done
    
    cat "${new_hosts_content}" > "${HOSTS_FILE}" || { log "BŁĄD: Nie można nadpisać pliku hosts."; exit 1; }
    log "Plik ${HOSTS_FILE} został pomyślnie zaktualizowany."
    rm -f "${temp_hosts}" "${new_hosts_content}" "${temp_exclusions_filtered}"
}

# --- === Zarządzanie Zaporą Sieciową === ---
manage_firewall() {
    log "Rozpoczynam konfigurację zapory sieciowej..."
    clean_firewall_rules
    # ... (Reszta funkcji bez zmian) ...
}
clean_firewall_rules() {
    # ... (Reszta funkcji bez zmian) ...
}

# --- === Hartowanie Jądra (sysctl) === ---
harden_kernel() {
    log "Rozpoczynam hartowanie parametrów jądra (sysctl)..."
    local sysctl_conf="/etc/sysctl.d/99-udfl.conf"
    
    cat > "${sysctl_conf}" << EOL
# Konfiguracja bezpieczeństwa sieciowego przez Ultra Defender for Linux
# Ochrona przed atakami SYN flood
net.ipv4.tcp_syncookies = 1
# Ignoruj pakiety ICMP redirect
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.default.accept_redirects = 0
# Ignoruj pakiety źródłowe (source-routed)
net.ipv4.conf.all.accept_source_route = 0
net.ipv4.conf.default.accept_source_route = 0
# Włącz pełną randomizację przestrzeni adresowej (ASLR)
kernel.randomize_va_space = 2
EOL

    sysctl -p "${sysctl_conf}"
    log "Zastosowano bezpieczne ustawienia jądra."
}

# --- === Integracja z Fail2Ban === ---
setup_fail2ban() {
    if ! command -v fail2ban-client &> /dev/null; then
        log "OSTRZEŻENIE: Narzędzie 'fail2ban' nie jest zainstalowane. Pomijam ten krok."
        log "Aby włączyć dynamiczną ochronę, zainstaluj fail2ban (np. sudo apt install fail2ban) i uruchom instalator ponownie."
        return 0
    fi

    log "Konfiguruję ochronę SSH za pomocą Fail2Ban..."
    local fail2ban_conf="/etc/fail2ban/jail.d/udfl-ssh.conf"
    
    cat > "${fail2ban_conf}" << EOL
# Konfiguracja ochrony SSH przez Ultra Defender for Linux
[sshd]
enabled = true
port = ssh
maxretry = 3
bantime = 1d
EOL

    fail2ban-client reload
    log "Aktywowano ochronę SSH w Fail2Ban."
}


# --- === Hartowanie Systemu === ---
harden_system() {
    log "Rozpoczynam hartowanie usług systemowych..."
    local services_to_disable=("whoopsie" "apport")
    for service in "${services_to_disable[@]}"; do
        if systemctl list-units --full -all | grep -q "${service}.service"; then
            systemctl disable --now "${service}" &> /dev/null || true
        fi
    done
}

# --- === Logika Deinstalacji === ---
uninstall_logic() {
    log "Rozpoczynam deinstalację..."
    
    # Przywracanie pliku hosts
    if [ -f "${BACKUP_DIR}/hosts.original" ]; then
        mv "${BACKUP_DIR}/hosts.original" "${HOSTS_FILE}" || { log "BŁĄD: Nie można przywrócić pliku hosts."; exit 1; }
        log "Plik hosts został przywrócony."
    else
        sed -i.bak '/# UDfL_BLOCK/d' "${HOSTS_FILE}"
    fi

    clean_firewall_rules

    # Usuwanie konfiguracji sysctl
    rm -f "/etc/sysctl.d/99-udfl.conf"
    sysctl -p
    log "Usunięto konfigurację sysctl."

    # Usuwanie konfiguracji Fail2Ban
    rm -f "/etc/fail2ban/jail.d/udfl-ssh.conf"
    if command -v fail2ban-client &> /dev/null; then
        fail2ban-client reload
    fi
    log "Usunięto konfigurację Fail2Ban."

    # Przywracanie usług
    local services_to_enable=("whoopsie" "apport")
    for service in "${services_to_enable[@]}"; do
        if systemctl list-units --full -all | grep -q "${service}.service" && ! systemctl is-enabled "${service}" &> /dev/null; then
            systemctl enable --now "${service}" &> /dev/null || true
        fi
    done

    rm -rf "${BACKUP_DIR}"
}

# --- === Główna Logika Skryptu === ---
main() {
    check_dependencies
    detect_downloader
    
    case "$1" in
        -install)
            log "=== Rozpoczynam instalację/aktualizację ${PROJECT_NAME} ==="
            manage_hosts
            manage_firewall
            harden_kernel
            setup_fail2ban
            harden_system
            log "=== Instalacja/Aktualizacja zakończona pomyślnie ==="
            ;;
        -uninstall)
            log "=== Rozpoczynam deinstalację ${PROJECT_NAME} ==="
            uninstall_logic
            log "=== Deinstalacja zakończona ==="
            ;;
        *)
            echo "Użycie: sudo bash $0 [-install | -uninstall]"
            exit 1
            ;;
    esac
}

main "$@"